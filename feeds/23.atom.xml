<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Gary Wilson Jr. - 23</title><link href="https://gdub.github.io/thegarywilson.com/" rel="alternate"></link><link href="https://gdub.github.io/thegarywilson.com/feeds/23.atom.xml" rel="self"></link><id>https://gdub.github.io/thegarywilson.com/</id><updated>2012-03-23T00:00:00-05:00</updated><entry><title>Software Metrics: A Django Case Study</title><link href="https://gdub.github.io/thegarywilson.com/blog/2012/software-metrics-a-django-case-study/" rel="alternate"></link><published>2012-03-23T00:00:00-05:00</published><updated>2012-03-23T00:00:00-05:00</updated><author><name>Gary</name></author><id>tag:gdub.github.io,2012-03-23:/thegarywilson.com/blog/2012/software-metrics-a-django-case-study/</id><summary type="html">&lt;p&gt;With the permission of the other authors, I'd like to share with you a couple of reports written for an assignment in the Software Measurement and Metrics graduate course I took last semester.
For this project, our class split into two teams that each performed their own case study on …&lt;/p&gt;</summary><content type="html">&lt;p&gt;With the permission of the other authors, I'd like to share with you a couple of reports written for an assignment in the Software Measurement and Metrics graduate course I took last semester.
For this project, our class split into two teams that each performed their own case study on the &lt;a class="reference external" href="https://www.djangoproject.com/"&gt;Django project&lt;/a&gt;.
The reports were submitted in November 2011, and thus analyzed code and bug data through about the end of October 2011.&lt;/p&gt;
&lt;p&gt;While I have &lt;a class="reference external" href="/blog/2006/cyclomatic-complexity-of-django/"&gt;previously analyzed Django's complexity&lt;/a&gt; (using a &lt;a class="reference external" href="/blog/2006/cyclomatic-complexity-for-python-code/"&gt;hack of some existing complexity scripts&lt;/a&gt;), the case studies presented here analyze several aspects of the Django project, including code size, code complexity, component quality, and test coverage.&lt;/p&gt;
&lt;div class="section" id="reports"&gt;
&lt;h2&gt;Reports&lt;/h2&gt;
&lt;p&gt;Below you will find excerpts describing the motivations for each report, followed by links to the full PDF versions of the reports.&lt;/p&gt;
&lt;div class="section" id="team-a"&gt;
&lt;h3&gt;Team A&lt;/h3&gt;
&lt;p&gt;Written by Eric Huneke, Brendan Long, and Gary Wilson Jr.&lt;/p&gt;
&lt;blockquote&gt;
This report describes our case study of Django, an open source web application framework written in Python. The overall goal of our study was a data-driven exploration of Django's code base, issue tracker, and wiki space, targeted to answer our research questions related to code size, complexity, and defect counts. We explored both the current state and the history of the Django project's artifacts, and produced several visualizations of the most interesting data.&lt;/blockquote&gt;
&lt;p&gt;&lt;a class="reference external" href="https://gdub.github.io/thegarywilson.com/blog/2012/software-metrics-a-django-case-study/django_case_study_team_a.pdf"&gt;Download report&lt;/a&gt; (815K, 19 pages).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="team-b"&gt;
&lt;h3&gt;Team B&lt;/h3&gt;
&lt;p&gt;Written by Kevin Boos, Richard Campbell, Evan Grim, and Hasanain A. Jwair.&lt;/p&gt;
&lt;blockquote&gt;
Our motivation for conducting this case study, aside from the obvious assignment requirements, is to answer a variety of research questions corresponding to several standard software metrics: code size, modularity, complexity, unit test coverage, and component quality relative to defect quantity. We believe that obtaining and analyzing data from the Django repositories and databases will allow us to generate graphical representations of important relationships between developer behavior, component organization, testing and debugging procedures, and a wide variety of other project characteristics. From these relationships, we can then draw conclusions about how to improve the software development process and other facets of the Django project.&lt;/blockquote&gt;
&lt;p&gt;&lt;a class="reference external" href="https://gdub.github.io/thegarywilson.com/blog/2012/software-metrics-a-django-case-study/django_case_study_team_b.pdf"&gt;Download report&lt;/a&gt; (2.4M, 25 pages).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusions"&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;I encourage you to browse through the reports and their visualizations.  For the impatient, the teams' conclusions were as follows:&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;Team A&lt;/h3&gt;
&lt;blockquote&gt;
This report presented the data we collected as part of a case study examining various aspects of Django, an open source web application framework. We found that the codebase has been growing at a steady rate since its start and will likely continue to grow. Overall complexity has been manageable, with just a few files containing egregiously complex functions. A refactoring effort focused on the files presented in table 4.1 is recommended. Ticket data relating to Django reflect basic intuitions about how they should behave. We were able to get a rough measure of component quality by looking at the number of tickets relating to each component, and showed that the top three components by ticket count (documentation, database layer, and contrib.admin) accounted for over 40% of all reported tickets. Test coverage of Django's components is high, with most components having at least 95% coverage. Coverage has trended upward for almost the entire project's history, and saw an extreme increase in the time periods before its 1.0 release.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;Team B&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;This case study of the Django project, an open-source web development framework composed in Python, has presented a wide variety of statistically-significant data. To measure code size, rate of growth, complexity, and maintainability, we used Django's source control repository to analyze historical revisions since 2005. To analyze defect tracking, we looked at ticket records dating to the beginning of the Django project. For unit testing coverage, coding standards, and style guidelines analysis, we analyzed source code that was extracted from the Django subversion server on October 31, 2011.&lt;/p&gt;
&lt;p&gt;We found that the size of the project has greatly increased since its start, but that the rate of increase has decreased over time. The largest component with approximately half of the code is the contrib component which could be broken up into smaller, more manageable components. The overall cyclomatic complexity of Django is 2.49 which is respectable. Complexity started out nice and increased for the first few years, but has decreased since the initial increase. Some modules, though, have high complexities which should be reduced if possible.&lt;/p&gt;
&lt;p&gt;The ticket data showed that the majority of the tickets opened were for defects. When looking at only the defect tickets, we found 4 components out of 48 had almost 60% of the defects opened against them. The core and database components have the most defects per SLOC, so improving code quality in these areas will greatly reduce the overall number of defects in the Django project.&lt;/p&gt;
&lt;p&gt;As a whole, we found that the Django code is well covered by its test cases. The component with the lowest coverage, contrib.admin, was also found to be one of the components with the highest number of defects opened against it. Improving test coverage may reduce the number of tickets opened.&lt;/p&gt;
&lt;p&gt;We found that python coding standards and style conventions are poorly followed by Django developers. Additionally, Django code is poorly commented, only 7% of the total lines of the code base were comment lines. We also found that the amount of documentation is not consistent throughout the code elements, while most of the methods are documented, less than half the modules and classes have documentations.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="23"></category><category term="django"></category><category term="grad school"></category><category term="metrics"></category><category term="python"></category></entry><entry><title>is_authenticated() vs. is_anonymous()</title><link href="https://gdub.github.io/thegarywilson.com/blog/2006/is_authenticated-vs-is_anonymous/" rel="alternate"></link><published>2006-09-23T00:00:00-05:00</published><updated>2006-09-23T00:00:00-05:00</updated><author><name>Gary</name></author><id>tag:gdub.github.io,2006-09-23:/thegarywilson.com/blog/2006/is_authenticated-vs-is_anonymous/</id><summary type="html">&lt;p&gt;A warning for those who might not of noticed the change.  About a month ago (in &lt;a class="reference external" href="http://code.djangoproject.com/changeset/3360"&gt;[3360]&lt;/a&gt;), an &lt;tt class="docutils literal"&gt;is_authenticated&lt;/tt&gt; method was added to the User and AnonymousUser classes.  These are the classes used for Django's default authentication system.&lt;/p&gt;
&lt;p&gt;Previously, the template code used for displaying content based on whether or …&lt;/p&gt;</summary><content type="html">&lt;p&gt;A warning for those who might not of noticed the change.  About a month ago (in &lt;a class="reference external" href="http://code.djangoproject.com/changeset/3360"&gt;[3360]&lt;/a&gt;), an &lt;tt class="docutils literal"&gt;is_authenticated&lt;/tt&gt; method was added to the User and AnonymousUser classes.  These are the classes used for Django's default authentication system.&lt;/p&gt;
&lt;p&gt;Previously, the template code used for displaying content based on whether or not a user had authenticated went something like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;user.is_anonymous&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;Content for logged in users.&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;Content for non-logged in users.&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;endif&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The problem with this code is that if, somehow, the &lt;tt class="docutils literal"&gt;user&lt;/tt&gt; template variable did not get populated, your template would treat the requesting user as if they were logged in.&lt;/p&gt;
&lt;p&gt;Notice that this sort of behavior will be seen for &lt;strong&gt;all&lt;/strong&gt; negative if statements.  The template code &lt;tt class="docutils literal"&gt;{% if not variable %}&lt;/tt&gt; will always evaluate to &lt;tt class="docutils literal"&gt;True&lt;/tt&gt; if &lt;tt class="docutils literal"&gt;variable&lt;/tt&gt; doesn't exist in the context.  This is because Django uses the &lt;a class="reference external" href="http://www.djangoproject.com/documentation/settings/#template-string-if-invalid"&gt;settings.TEMPLATE_STRING_IF_INVALID&lt;/a&gt; value for non-existent template variables; by default, &lt;tt class="docutils literal"&gt;TEMPLATE_STRING_IF_INVALID&lt;/tt&gt; is &lt;tt class="docutils literal"&gt;''&lt;/tt&gt;, which evaluates to &lt;tt class="docutils literal"&gt;False&lt;/tt&gt; (and &lt;tt class="docutils literal"&gt;not False&lt;/tt&gt; is &lt;tt class="docutils literal"&gt;True&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;Notice also that even using the template code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;user.is_anonymous&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;Content for non-logged in users.&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;Content for logged in users.&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;endif&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(without the &lt;tt class="docutils literal"&gt;not&lt;/tt&gt;) will not work in this case because if the &lt;tt class="docutils literal"&gt;user&lt;/tt&gt; variable is non-existent, the requesting user will still be treated as if they were authenticated.&lt;/p&gt;
&lt;p&gt;The new, recommended way for checking that a requesting user has been authenticated in your templates is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;user.is_authenticated&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;Content for logged in users.&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;Content for non-logged in users&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;endif&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, if the &lt;tt class="docutils literal"&gt;user&lt;/tt&gt; template variable were to not exist, your template would treat the requesting user as non-authenticated, just as we would want.&lt;/p&gt;
</content><category term="23"></category><category term="authentication"></category><category term="django"></category><category term="templates"></category></entry></feed>